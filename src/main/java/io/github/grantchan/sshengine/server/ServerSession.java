package io.github.grantchan.sshengine.server;

import io.github.grantchan.sshengine.arch.SshMessage;
import io.github.grantchan.sshengine.common.AbstractSession;
import io.github.grantchan.sshengine.common.transport.compression.Compression;
import io.github.grantchan.sshengine.server.connection.AbstractServerChannel;
import io.github.grantchan.sshengine.server.connection.SessionChannel;
import io.github.grantchan.sshengine.util.buffer.ByteBufIo;
import io.netty.buffer.ByteBuf;
import io.netty.channel.Channel;

import javax.crypto.Cipher;
import javax.crypto.Mac;
import java.math.BigInteger;

public class ServerSession extends AbstractSession {

  public ServerSession(Channel channel) {
    super(channel);
  }

  @Override
  public Cipher getInCipher() {
    return getC2sCipher();
  }

  @Override
  public void setInCipher(Cipher inCipher) {
    setC2sCipher(inCipher);
  }

  @Override
  public Cipher getOutCipher() {
    return getS2cCipher();
  }

  @Override
  public void setOutCipher(Cipher outCipher) {
    setS2cCipher(outCipher);
  }

  @Override
  public int getInCipherBlkSize() {
    return getC2sCipherBlkSize();
  }

  @Override
  public void setInCipherBlkSize(int inBlkSize) {
    setC2sCipherBlkSize(inBlkSize);
  }

  @Override
  public int getOutCipherBlkSize() {
    return getS2cCipherBlkSize();
  }

  @Override
  public void setOutCipherBlkSize(int outBlkSize) {
    setS2cCipherBlkSize(outBlkSize);
  }

  @Override
  public Mac getInMac() {
    return getC2sMac();
  }

  @Override
  public void setInMac(Mac inMac) {
    setC2sMac(inMac);
  }

  @Override
  public Mac getOutMac() {
    return getS2cMac();
  }

  @Override
  public void setOutMac(Mac outMac) {
    setS2cMac(outMac);
  }

  @Override
  public int getInMacSize() {
    return getC2sMacSize();
  }

  @Override
  public void setInMacSize(int inMacSize) {
    setC2sMacSize(inMacSize);
  }

  @Override
  public int getOutMacSize() {
    return getS2cMacSize();
  }

  @Override
  public void setOutMacSize(int outMacSize) {
    setS2cMacSize(outMacSize);
  }

  @Override
  public void setInDefMacSize(int inDefMacSize) {
    setC2sDefMacSize(inDefMacSize);
  }

  @Override
  public int getOutDefMacSize() {
    return getS2cDefMacSize();
  }

  @Override
  public void setOutDefMacSize(int outDefMacSize) {
    setS2cDefMacSize(outDefMacSize);
  }

  @Override
  public Compression getInCompression() {
    return getC2sCompression();
  }

  @Override
  public void setInCompression(Compression inCompression) {
    setC2sCompression(inCompression);
  }

  @Override
  public Compression getOutCompression() {
    return getS2cCompression();
  }

  @Override
  public void setOutCompression(Compression outCompression) {
    setS2cCompression(outCompression);
  }

  /**
   * Sends the {@link SshMessage#SSH_MSG_SERVICE_ACCEPT} message to the client to notify the client
   * the service can be supported, and permits to use.
   *
   * @param svcName  the service name requested by client
   *
   * @see <a href="https://tools.ietf.org/html/rfc4253#section-10">Service Request</a>
   */
  public void replyAccept(String svcName) {
    ByteBuf buf = createMessage(SshMessage.SSH_MSG_SERVICE_ACCEPT);

    ByteBufIo.writeUtf8(buf, svcName);

    logger.debug("[{}] Replying SSH_MSG_SERVICE_ACCEPT...", this);

    channel.writeAndFlush(buf);
  }

  public void replyKexDhReply(byte[] k_s, BigInteger f, byte[] sigH) {
    ByteBuf reply = createMessage(SshMessage.SSH_MSG_KEXDH_REPLY);

    ByteBufIo.writeBytes(reply, k_s);
    ByteBufIo.writeMpInt(reply, f);
    ByteBufIo.writeBytes(reply, sigH);

    logger.debug("[{}] Replying SSH_MSG_KEXDH_REPLY...", this);

    channel.writeAndFlush(reply);
  }

  /**
   * Sends the {@link SshMessage#SSH_MSG_KEX_DH_GEX_REPLY} to client. This is the message of step 4
   * in diffie-hellman group key exchange.
   *
   * @param k_s     server public host key and certificates (K_S)
   * @param f       f = g^y mod p, where y is a random number generated by server, 0 < y < (p-1)/2
   * @param sigH    signature of H
   *
   * @see <a href="https://tools.ietf.org/html/rfc4419#section-3">Diffie-Hellman Group and Key Exchange</a>
   */
  public void replyKexDhGexReply(byte[] k_s, BigInteger f, byte[] sigH) {
    ByteBuf reply = createMessage(SshMessage.SSH_MSG_KEX_DH_GEX_REPLY);

    ByteBufIo.writeBytes(reply, k_s);
    ByteBufIo.writeMpInt(reply, f);
    ByteBufIo.writeBytes(reply, sigH);

    logger.debug("[{}] Replying SSH_MSG_KEX_DH_GEX_REPLY...", this);

    channel.writeAndFlush(reply);
  }

  @Override
  public void requestUserAuthRequest(String user, String service, String method) {
    throw new UnsupportedOperationException("Server doesn't support sending user auth request");
  }

  @Override
  public void requestServiceRequest() {
    throw new UnsupportedOperationException("Server doesn't support sending service request");
  }

  /**
   * Sends the {@link SshMessage#SSH_MSG_USERAUTH_SUCCESS} message to client to notify the
   * authentication request is accepted.
   *
   * <p>Note that this is not sent after each step in a multi-method authentication sequence, but
   * only when the authentication is complete.</p>
   *
   * <p>The client MAY send several authentication requests without waiting for responses from
   * previous requests. The server MUST process each request completely and acknowledge any failed
   * requests with a {@link SshMessage#SSH_MSG_USERAUTH_FAILURE} message before processing the next
   * request.</p>
   *
   * <p>A request that requires further messages to be exchanged will be aborted by a subsequent
   * request. A client MUST NOT send a subsequent request if it has not received a response from
   * the server for a previous request. A {@link SshMessage#SSH_MSG_USERAUTH_FAILURE} message MUST
   * NOT be sent for an aborted method.</p>
   *
   * <p>{@link SshMessage#SSH_MSG_USERAUTH_SUCCESS} MUST be sent only once. When
   * {@link SshMessage#SSH_MSG_USERAUTH_SUCCESS} has been sent, any further authentication requests
   * received after that SHOULD be silently ignored.</p>
   *
   * <p>Any non-authentication messages sent by the client after the request that resulted in
   * {@link SshMessage#SSH_MSG_USERAUTH_SUCCESS} being sent MUST be passed to the service being run
   * on top of this protocol. Such messages can be identified by their message numbers
   * (see Section 6).</p>
   *
   * @see <a href="https://tools.ietf.org/html/rfc4252#section-5.1">Responses to Authentication Requests</a>
   */
  public void replyUserAuthSuccess() {
    ByteBuf uas = createMessage(SshMessage.SSH_MSG_USERAUTH_SUCCESS);

    logger.debug("[{}] Replying SSH_MSG_USERAUTH_SUCCESS...", this);

    channel.writeAndFlush(uas);
  }

  /**
   * Sends the SSH_MSG_USERAUTH_FAILURE message to client to reject the authentication request.
   *
   * <p>It is RECOMMENDED that servers only include those 'method name' values
   * in the name-list that are actually useful. However, it is not illegal to
   * include 'method name' values that cannot be used to authenticate the
   * user.</p>
   * <p>Already successfully completed authentications SHOULD NOT be included in
   * the name-list, unless they should be performed again for some reason.</p>
   *
   * @param remainMethods   a comma-separated name-list of authentication 'method name' values that
   *                        may productively continue the authentication dialog.
   * @param partialSuccess  MUST be {@code true} if the authentication request to which this is a
   *                        response was successful. It MUST be {@code FALSE} if the request was not
   *                        successfully processed.
   * @see <a href="https://tools.ietf.org/html/rfc4252#section-5.1">Responses to Authentication Requests</a>
   */
  public void replyUserAuthFailure(String remainMethods, boolean partialSuccess) {
    ByteBuf uaf = createMessage(SshMessage.SSH_MSG_USERAUTH_FAILURE);

    ByteBufIo.writeUtf8(uaf, remainMethods);
    uaf.writeBoolean(partialSuccess);

    logger.debug("[{}] Replying SSH_MSG_USERAUTH_FAILURE...", this);

    channel.writeAndFlush(uaf);
  }

  /**
   * Sends the SSH_MSG_USERAUTH_PK_OK message to tell client the pass phase in public key
   * authentication process is successful.
   *
   * @param algorithm  public key algorithm name that server received in SSH_MSG_USERAUTH_REQUEST
   * @param blob       public key blob that server received in SSH_MSG_USERAUTH_REQUEST
   * @see <a href="https://tools.ietf.org/html/rfc4252#section-7">Public Key Authentication Method: "publickey"</a>
   */
  public void replyUserAuthPkOk(String algorithm, byte[] blob) {
    ByteBuf uapo = createMessage(SshMessage.SSH_MSG_USERAUTH_PK_OK);

    ByteBufIo.writeUtf8(uapo, algorithm);
    ByteBufIo.writeBytes(uapo, blob);

    logger.debug("[{}] Replying SSH_MSG_USERAUTH_PK_OK...", this);

    channel.writeAndFlush(uapo);
  }

  public void replyChannelOpenConfirmation(int rChId, int lChId, int wndSize, int wndPacketSize) {
    ByteBuf conf = createMessage(SshMessage.SSH_MSG_CHANNEL_OPEN_CONFIRMATION);

    conf.writeInt(rChId);
    conf.writeInt(lChId);
    conf.writeInt(wndSize);
    conf.writeInt(wndPacketSize);

    logger.debug("[{}] Replying SSH_MSG_CHANNEL_OPEN_CONFIRMATION... remote id:{}, local id:{}," +
        " window size:{}, packet size:{}", this, rChId, lChId, wndSize, wndPacketSize);

    channel.writeAndFlush(conf);
  }

  public void replyChannelOpenFailure(int peerId, int reason, String message, String lang) {
    ByteBuf cof = createMessage(SshMessage.SSH_MSG_CHANNEL_OPEN_FAILURE);

    cof.writeInt(peerId);
    cof.writeInt(reason);
    ByteBufIo.writeUtf8(cof, message);
    ByteBufIo.writeUtf8(cof, lang);

    logger.debug("[{}] Replying SSH_MSG_CHANNEL_OPEN_FAILURE... remote channel id:{}, reason code:{}," +
        " message:{}, lang:{}", this, peerId, reason, message, lang);

    channel.writeAndFlush(cof);
  }

  public AbstractServerChannel createChannel(String type) {
    if (type != null && type.equals("session")) {
      return new SessionChannel(this);
    }

    return null;
  }
}
